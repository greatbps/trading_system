#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
trading_system/data_collectors/kis_collector.py

Production-Ready KIS (Korea Investment & Securities) API Collector
"""

import asyncio
import aiohttp
import json
import time
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any, Union, AsyncContextManager
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum
from contextlib import asynccontextmanager
import logging
from decimal import Decimal
import math
import random

# Third-party imports
try:
    from pykis import PyKis
    Api = PyKis  # Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú alias
    print("SUCCESS: pykis PyKis imported successfully")
except ImportError as e:
    Api = None
    print(f"FATAL: Failed to import pykis components: {e}")
    
# Local imports
from utils.logger import get_logger

# Enums for type safety
class Market(Enum):
    """Market classification"""
    KOSPI = "KOSPI"
    KOSDAQ = "KOSDAQ"
    KONEX = "KONEX"

class APIStatus(Enum):
    """API connection status"""
    CONNECTED = "CONNECTED"
    DISCONNECTED = "DISCONNECTED"
    RATE_LIMITED = "RATE_LIMITED"
    ERROR = "ERROR"

# Custom exceptions for better error handling
class KISAPIError(Exception):
    """Base exception for KIS API errors"""
    def __init__(self, message: str, error_code: Optional[str] = None, response_data: Optional[Dict] = None):
        super().__init__(message)
        self.error_code = error_code
        self.response_data = response_data
        
class KISAuthenticationError(KISAPIError):
    """Authentication related errors"""
    pass
    
class KISRateLimitError(KISAPIError):  
    """Rate limiting errors"""
    pass
    
class KISNetworkError(KISAPIError):
    """Network related errors"""
    pass
    
class KISDataValidationError(KISAPIError):
    """Data validation errors"""
    pass

# Data models with comprehensive validation
@dataclass
class StockData:
    """Enhanced stock data model with validation"""
    symbol: str
    name: str
    current_price: int  # Korean won - no decimals
    change_rate: float
    volume: int
    trading_value: float  # In millions
    market_cap: float    # In billions
    market: Market
    
    # Extended data
    shares_outstanding: Optional[int] = None
    high_52w: Optional[int] = None
    low_52w: Optional[int] = None
    pe_ratio: Optional[float] = None
    pbr: Optional[float] = None
    eps: Optional[int] = None
    bps: Optional[int] = None
    sector: Optional[str] = "Í∏∞ÌÉÄ"
    
    # Metadata
    last_updated: datetime = field(default_factory=datetime.now)
    data_source: str = "KIS_API"
    
    def __post_init__(self):
        """Validate data after initialization"""
        if len(self.symbol) != 6 or not self.symbol.isdigit():
            raise ValueError(f"Invalid symbol format: {self.symbol}")
        if self.current_price <= 0:
            raise ValueError(f"Invalid price: {self.current_price}")
        if self.volume < 0:
            raise ValueError(f"Invalid volume: {self.volume}")

@dataclass
class OHLCVData:
    """OHLCV candlestick data"""
    symbol: str
    datetime: datetime
    timeframe: str  # 1m, 5m, 15m, 1h, 1d, etc.
    open_price: int
    high_price: int
    low_price: int
    close_price: int
    volume: int
    trade_amount: Optional[int] = None
    
    def __post_init__(self):
        """Validate OHLCV data"""
        if not all(p > 0 for p in [self.open_price, self.high_price, self.low_price, self.close_price]):
            raise ValueError("All prices must be positive")
        if self.high_price < self.low_price:
            raise ValueError("High price cannot be less than low price")
        if self.volume < 0:
            raise ValueError("Volume cannot be negative")
    
    # Compatibility properties for AnalysisEngine
    @property
    def date(self) -> datetime:
        """Date property for backward compatibility"""
        return self.datetime
    
    @property
    def open(self) -> int:
        """Open price property for backward compatibility"""
        return self.open_price
    
    @property  
    def high(self) -> int:
        """High price property for backward compatibility"""
        return self.high_price
    
    @property
    def low(self) -> int:
        """Low price property for backward compatibility"""
        return self.low_price
    
    @property
    def close(self) -> int:
        """Close price property for backward compatibility"""
        return self.close_price

# Rate limiter for API compliance
class RateLimiter:
    """Token bucket rate limiter for KIS API (20 requests/second)"""
    
    def __init__(self, max_requests: int = 20, time_window: int = 1):
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = []
        self._lock = asyncio.Lock()
        
    async def acquire(self) -> bool:
        """Acquire rate limit permission"""
        async with self._lock:
            now = time.time()
            
            # Remove old requests outside time window
            self.requests = [req_time for req_time in self.requests if now - req_time < self.time_window]
            
            if len(self.requests) < self.max_requests:
                self.requests.append(now)
                return True
            
            # Calculate wait time
            oldest_request = min(self.requests)
            wait_time = self.time_window - (now - oldest_request)
            
            if wait_time > 0:
                await asyncio.sleep(wait_time)
                return await self.acquire()
            
            return True

class KISTokenManager:
    """Enhanced token manager with file-based caching and auto-refresh"""
    
    def __init__(self, app_key: str, app_secret: str, base_url: str, logger: logging.Logger, virtual_mode: bool = True):
        self.app_key = app_key
        self.app_secret = app_secret
        self.base_url = base_url
        self.logger = logger
        self.virtual_mode = virtual_mode
        
        # Token state
        self.access_token: Optional[str] = None
        self.token_expired: Optional[datetime] = None
        self.refresh_threshold = timedelta(hours=1)  # Refresh 1 hour before expiry
        
        # File-based token cache
        import os
        self.token_cache_file = os.path.join("data", "kis_token_cache.json")
        os.makedirs("data", exist_ok=True)
        
        # Lock for thread safety
        self._lock = asyncio.Lock()
        
        # Load cached token on initialization
        self._load_cached_token()
    
    async def request_new_token(self, session: aiohttp.ClientSession) -> bool:
        """Request new access token with comprehensive error handling"""
        async with self._lock:
            try:
                self.logger.info("üîë ÏÉà Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ ÏöîÏ≤≠ Ï§ë...")
                
                endpoint = "/oauth2/tokenP"
                url = f"{self.base_url}{endpoint}"
                
                payload = {
                    "grant_type": "client_credentials",
                    "appkey": self.app_key,
                    "appsecret": self.app_secret
                }
                
                headers = {
                    'Content-Type': 'application/json',
                    'User-Agent': 'TradingSystem/2.0'
                }
                
                # Make request with timeout
                timeout = aiohttp.ClientTimeout(total=10, connect=5)
                async with session.post(url, json=payload, headers=headers, timeout=timeout) as response:
                    response_text = await response.text()
                    
                    if response.status == 200:
                        try:
                            result = await response.json()
                            
                            # Validate response structure
                            if 'access_token' not in result:
                                raise KISAuthenticationError("Access token not found in response")
                            
                            self.access_token = result['access_token']
                            # KIS tokens typically expire in 24 hours
                            self.token_expired = datetime.now() + timedelta(hours=23, minutes=50)
                            
                            # ÌÜ†ÌÅ∞ÏùÑ ÌååÏùºÏóê Ï∫êÏãú
                            self._save_token_to_cache()
                            
                            self.logger.info(f"‚úÖ ÏÉà Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ ÌöçÎìù ÏôÑÎ£å (ÎßåÎ£å: {self.token_expired})")
                            return True
                            
                        except json.JSONDecodeError as e:
                            raise KISAuthenticationError(f"Invalid JSON response: {e}")
                            
                    elif response.status == 401:
                        raise KISAuthenticationError(f"Authentication failed: {response_text}")
                    elif response.status == 429:
                        raise KISRateLimitError(f"Rate limit exceeded: {response_text}")
                    else:
                        raise KISAPIError(f"Token request failed with status {response.status}: {response_text}")
                        
            except asyncio.TimeoutError:
                raise KISNetworkError("Token request timed out")
            except aiohttp.ClientError as e:
                raise KISNetworkError(f"Network error during token request: {e}")
            except KISAPIError:
                raise  # Re-raise KIS-specific errors
            except Exception as e:
                raise KISAPIError(f"Unexpected error during token request: {e}")
    
    def is_token_valid(self) -> bool:
        """Check if current token is valid and not near expiry"""
        if not self.access_token or not self.token_expired:
            return False
        return datetime.now() < self.token_expired - self.refresh_threshold
    
    def get_headers(self, tr_id: Optional[str] = None, custtype: str = "P") -> Dict[str, str]:
        """Get API headers with optional transaction ID"""
        if not self.access_token:
            raise KISAuthenticationError("No valid access token available")
            
        headers = {
            'Authorization': f'Bearer {self.access_token}',
            'appkey': self.app_key,
            'appsecret': self.app_secret,
            'Content-Type': 'application/json',
            'User-Agent': 'TradingSystem/2.0'
        }
        
        if tr_id:
            headers['tr_id'] = tr_id
        if custtype:
            headers['custtype'] = custtype
            
        return headers
        
    async def ensure_valid_token(self, session: aiohttp.ClientSession) -> bool:
        """Ensure we have a valid token, refresh if necessary"""
        if self.is_token_valid():
            return True
            
        self.logger.info("ÌÜ†ÌÅ∞ ÎßåÎ£å ÏûÑÎ∞ï, ÏÉàÎ°úÏö¥ ÌÜ†ÌÅ∞ ÏöîÏ≤≠...")
        return await self.request_new_token(session)
    
    def _load_cached_token(self):
        """Load cached token from file"""
        try:
            import os
            if os.path.exists(self.token_cache_file):
                with open(self.token_cache_file, 'r', encoding='utf-8') as f:
                    cache_data = json.load(f)
                    self.access_token = cache_data.get('access_token')
                    if cache_data.get('token_expired'):
                        self.token_expired = datetime.fromisoformat(cache_data['token_expired'])
                    self.logger.info("Ï∫êÏãúÎêú ÌÜ†ÌÅ∞ Î°úÎìú ÏôÑÎ£å")
        except Exception as e:
            self.logger.warning(f"ÌÜ†ÌÅ∞ Ï∫êÏãú Î°úÎìú Ïã§Ìå®: {e}")
            self.access_token = None
            self.token_expired = None
    
    def _save_token_to_cache(self):
        """Save token to cache file"""
        try:
            import os
            cache_data = {
                'access_token': self.access_token,
                'token_expired': self.token_expired.isoformat() if self.token_expired else None
            }
            with open(self.token_cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, ensure_ascii=False, indent=2)
            self.logger.debug("ÌÜ†ÌÅ∞ Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å")
        except Exception as e:
            self.logger.warning(f"ÌÜ†ÌÅ∞ Ï∫êÏãú Ï†ÄÏû• Ïã§Ìå®: {e}")

class KISCollector:
    """Production-ready KIS API Collector with enterprise features"""
    
    def __init__(self, config, pykis_api: Any = None, logger: Optional[logging.Logger] = None):
        self.config = config
        self.logger = logger or get_logger("KISCollector")
        
        # API Configuration
        self.base_url = config.api.KIS_BASE_URL
        self.app_key = config.api.KIS_APP_KEY
        self.app_secret = config.api.KIS_APP_SECRET
        self.is_virtual = getattr(config.api, 'KIS_VIRTUAL_ACCOUNT', True)
        self.pykis_api = pykis_api # pykis_api ÏÜçÏÑ± Ï¥àÍ∏∞Ìôî
        
        if not self.app_key or not self.app_secret:
            raise ValueError("KIS API credentials not configured")
        
        # Core components
        self.token_manager = None
        self.session: Optional[aiohttp.ClientSession] = None
        self.rate_limiter = RateLimiter(max_requests=20, time_window=1)
        
        # Performance metrics
        self.metrics = {
            'requests_made': 0,
            'requests_failed': 0,
            'average_response_time': 0.0,
            'last_request_time': None
        }
        
        # Status
        self.status = APIStatus.DISCONNECTED
        self.last_error = None
        
        self.logger.info(f"KISCollector Ï¥àÍ∏∞Ìôî ÏôÑÎ£å (virtual: {self.is_virtual})")
    
    async def __aenter__(self) -> 'KISCollector':
        """Async context manager entry"""
        await self.initialize()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.close()
    
    async def initialize(self) -> bool:
        """Initialize the collector with all components"""
        try:
            self.logger.info("üöÄ KIS API collector Ï¥àÍ∏∞Ìôî Ï§ë...")
            
            self.token_manager = KISTokenManager(
                self.app_key, self.app_secret, self.base_url, self.logger, self.is_virtual
            )
            
            # Í∞ÑÏÜåÌôîÎêú ÏÑ∏ÏÖò ÏÑ§Ï†ï
            timeout = aiohttp.ClientTimeout(total=30, connect=10, sock_read=20)
            self.session = aiohttp.ClientSession(
                timeout=timeout,
                headers={'Content-Type': 'application/json', 'User-Agent': 'TradingSystem/2.0'}
            )
            
            # ÌÜ†ÌÅ∞ ÌôïÏù∏/ÌöçÎìù (Ï∫êÏãúÎêú ÌÜ†ÌÅ∞Ïù¥ Ïú†Ìö®ÌïòÎ©¥ Ïû¨ÏÇ¨Ïö©)
            await self.token_manager.ensure_valid_token(self.session)
            
            self.status = APIStatus.CONNECTED
            self.logger.info("‚úÖ KIS API collector Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
            return True
            
        except Exception as e:
            self.status = APIStatus.ERROR
            self.last_error = str(e)
            self.logger.error(f"‚ùå KIS collector Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
            raise KISAPIError(f"Initialization failed: {e}")
    
    async def close(self):
        """Clean up resources"""
        try:
            self.logger.info("KIS API collector Ï¢ÖÎ£å Ï§ë...")
            if self.session and not self.session.closed:
                await self.session.close()
                await asyncio.sleep(0.1)
            self.session = None
            self.status = APIStatus.DISCONNECTED
            self.logger.info("‚úÖ KIS API collector Ï¢ÖÎ£å ÏôÑÎ£å")
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Ï¢ÖÎ£å Ï§ë Ïò§Î•ò: {e}")
    
    async def _make_api_request(
        self, method: str, endpoint: str, params: Optional[Dict] = None,
        data: Optional[Dict] = None, tr_id: Optional[str] = None,
        custtype: str = "P", retry_count: int = 3
    ) -> Dict[str, Any]:
        """Make API request with proper error handling"""
        if not self.session:
            raise KISAPIError("Session not initialized")
        
        await self.rate_limiter.acquire()
        
        # URL Ï°∞Ìï© Ïãú Ï§ëÎ≥µ Ïä¨ÎûòÏãú Î∞©ÏßÄ
        if self.base_url.endswith('/') and endpoint.startswith('/'):
            url = f"{self.base_url[:-1]}{endpoint}"
        elif not self.base_url.endswith('/') and not endpoint.startswith('/'):
            url = f"{self.base_url}/{endpoint}"
        else:
            url = f"{self.base_url}{endpoint}"
        
        request_start_time = time.time()
        
        for attempt in range(retry_count):
            try:
                await self.token_manager.ensure_valid_token(self.session)
                headers = self.token_manager.get_headers(tr_id=tr_id, custtype=custtype)

                # ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä (ÏúÑÏπò ÏàòÏ†ï)
                self.logger.debug(f"---> API Request [Attempt {attempt+1}/{retry_count}] ---")
                self.logger.debug(f"URL: {method} {url}")
                self.logger.debug(f"Headers: {headers}")
                self.logger.debug(f"Params: {params}")
                self.logger.debug(f"Data: {data}")
                self.logger.debug("--------------------------------------")
                
                async with self.session.request(method, url, params=params, json=data, headers=headers) as response:
                    response_text = await response.text()
                    self.metrics['requests_made'] += 1
                    response_time = time.time() - request_start_time
                    self._update_response_time(response_time)

                    # <--- API Response Î°úÍ∑∏ Ï∂îÍ∞Ä
                    self.logger.debug(f"<--- API Response [Status: {response.status}] ---")
                    self.logger.debug(f"Response Body: {response_text[:500]}...") # ÎÑàÎ¨¥ Í∏∏Î©¥ ÏûòÎùºÏÑú ÌëúÏãú
                    self.logger.debug("--------------------------------------")
                    
                    if response.status == 200:
                        try:
                            result = await response.json()
                            # rt_cdÍ∞Ä 0Ïù¥ ÏïÑÎãå Í≤ΩÏö∞, KIS API Î†àÎ≤®Ïùò Ïò§Î•òÎ°ú Í∞ÑÏ£º
                            if result.get('rt_cd') != '0':
                                self.logger.warning(f"KIS API Error: {result.get('msg1')}")
                                # Ïã§Ìå®Î°ú Í∞ÑÏ£ºÌïòÍ≥† Ïû¨ÏãúÎèÑ Î°úÏßÅÏùÑ ÌÉà Ïàò ÏûàÎèÑÎ°ù ÏòàÏô∏ Î∞úÏÉù
                                raise KISAPIError(f"KIS API returned error: {result.get('msg1')}", response_data=result)

                            self.logger.debug(f"‚úÖ API ÏöîÏ≤≠ ÏÑ±Í≥µ: {method} {endpoint}")
                            return result
                        except json.JSONDecodeError as e:
                            raise KISAPIError(f"Invalid JSON response: {e}")
                    
                    elif response.status == 401:
                        self.logger.info("ÌÜ†ÌÅ∞ ÎßåÎ£å, ÏÉàÎ°úÍ≥†Ïπ® Ï§ë...")
                        await self.token_manager.request_new_token(self.session)
                        continue
                    
                    elif response.status == 429:
                        wait_time = 2 ** attempt
                        self.logger.warning(f"Rate limited, {wait_time}Ï¥à ÎåÄÍ∏∞...")
                        await asyncio.sleep(wait_time)
                        continue
                    
                    elif response.status >= 500:
                        if attempt < retry_count - 1:
                            wait_time = (2 ** attempt) + random.uniform(0, 1)
                            self.logger.warning(f"ÏÑúÎ≤Ñ Ïò§Î•ò {response.status}, {wait_time:.1f}Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ...")
                            await asyncio.sleep(wait_time)
                            continue
                        else:
                            raise KISAPIError(f"Server error {response.status}: {response_text}")
                    
                    else:
                        raise KISAPIError(f"API request failed with status {response.status}: {response_text}")
            
            except asyncio.TimeoutError:
                if attempt < retry_count - 1:
                    wait_time = 2 ** attempt
                    self.logger.warning(f"ÏöîÏ≤≠ ÌÉÄÏûÑÏïÑÏõÉ, {wait_time}Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ...")
                    await asyncio.sleep(wait_time)
                    continue
                else:
                    raise KISNetworkError("Request timed out after retries")
            
            except aiohttp.ClientError as e:
                if attempt < retry_count - 1:
                    wait_time = 2 ** attempt
                    self.logger.warning(f"ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò, {wait_time}Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ: {e}")
                    await asyncio.sleep(wait_time)
                    continue
                else:
                    raise KISNetworkError(f"Network error: {e}")
        
        self.metrics['requests_failed'] += 1
        raise KISAPIError("Max retry attempts exceeded")
    
    def _update_response_time(self, response_time: float):
        """Update average response time metric"""
        if self.metrics['average_response_time'] == 0:
            self.metrics['average_response_time'] = response_time
        else:
            self.metrics['average_response_time'] = (0.9 * self.metrics['average_response_time'] + 0.1 * response_time)
        self.metrics['last_request_time'] = datetime.now()

    async def get_stock_info(self, symbol: str) -> Optional[StockData]:
        """Ï£ºÏãù Ï†ïÎ≥¥ Ï°∞Ìöå"""
        try:
            if not symbol or len(symbol) != 6 or not symbol.isdigit():
                raise KISDataValidationError(f"Invalid symbol format: {symbol}")
            
            self.logger.debug(f"üìä {symbol} Ï£ºÏãù Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë...")
            
            result = await self._make_api_request(
                method="GET",
                endpoint="/uapi/domestic-stock/v1/quotations/inquire-price",
                params={"FID_COND_MRKT_DIV_CODE": "J", "FID_INPUT_ISCD": symbol},
                tr_id="FHKST01010100"
            )
            
            output = result.get('output', {})
            if not output:
                self.logger.warning(f"‚ö†Ô∏è {symbol} Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
                return None
            
            current_price = self._safe_int_parse(output.get('stck_prpr', '0'))
            if current_price <= 0:
                return None
            
            name = self._extract_stock_name(output, symbol)
            market_div = output.get('mrkt_div_cd', '')
            market = Market.KOSPI if market_div == "J" else Market.KOSDAQ
            
            stock_data = StockData(
                symbol=symbol, name=name, current_price=current_price,
                change_rate=self._safe_float_parse(output.get('prdy_ctrt', '0')),
                volume=self._safe_int_parse(output.get('acml_vol', '0')),
                trading_value=self._safe_float_parse(output.get('acml_tr_pbmn', '0')) / 1000000,
                market_cap=self._safe_float_parse(output.get('hts_avls', '0')) / 100,
                market=market,
                high_52w=self._safe_int_parse(output.get('w52_hgpr', '0')) or int(current_price * 1.5),
                low_52w=self._safe_int_parse(output.get('w52_lwpr', '0')) or int(current_price * 0.7),
                pe_ratio=self._safe_float_parse(output.get('per', '0')) or None,
                pbr=self._safe_float_parse(output.get('pbr', '0')) or None,
                sector="Í∏∞ÌÉÄ"
            )
            
            self.logger.debug(f"‚úÖ {symbol} Ï£ºÏãù Ï†ïÎ≥¥ Ï°∞Ìöå ÏÑ±Í≥µ")
            return stock_data
            
        except KISAPIError:
            raise
        except Exception as e:
            self.logger.error(f"‚ùå {symbol} Ï£ºÏãù Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: {e}")  
            raise KISAPIError(f"Failed to fetch stock info: {e}")

    def _extract_stock_name(self, output: Dict, symbol: str) -> str:
        """Ï£ºÏãùÎ™Ö Ï∂îÏ∂ú"""
        name_candidates = [
            output.get('hts_kor_isnm', '').strip(),
            output.get('prdy_vrss_sign', '').strip(),
            output.get('hts_kor_isnm_1', '').strip()
        ]
        for candidate in name_candidates:
            if candidate and not candidate.startswith('Ï¢ÖÎ™©') and len(candidate) > 2:
                return self._clean_stock_name(candidate)
        
        return f'Ï¢ÖÎ™©{symbol}'

    def _clean_stock_name(self, name: str) -> str:
        """Ï£ºÏãùÎ™Ö Ï†ïÎ¶¨"""
        if not name: return ""
        suffixes = ["Ïö∞", "Ïö∞B", "Ïö∞C", "1Ïö∞", "2Ïö∞", "3Ïö∞", "Ïä§Ìå©", "SPAC", "Î¶¨Ï∏†", "REIT", "ETF", "ETN"]
        clean_name = name.strip()
        for suffix in suffixes:
            if clean_name.endswith(suffix):
                clean_name = clean_name[:-len(suffix)].strip()
        return clean_name

    def _safe_int_parse(self, value: Any, default: int = 0) -> int:
        """ÏïàÏ†ÑÌïú int Î≥ÄÌôò"""
        try:
            if isinstance(value, int): return value
            if isinstance(value, float): return default if math.isnan(value) or math.isinf(value) else int(value)
            value_str = str(value).strip().replace(',', '')
            if not value_str or value_str.lower() in ['nan', 'none', 'null', '', 'nat', 'inf', '-inf']: return default
            return int(float(value_str)) if '.' in value_str else int(value_str)
        except (ValueError, TypeError): return default

    def _safe_float_parse(self, value: Any, default: float = 0.0) -> float:
        """ÏïàÏ†ÑÌïú float Î≥ÄÌôò"""
        try:
            if isinstance(value, (int, float)): return default if math.isnan(value) or math.isinf(value) else float(value)
            value_str = str(value).strip().replace(',', '')
            if not value_str or value_str.lower() in ['nan', 'none', 'null', '', 'nat', 'inf', '-inf']: return default
            float_val = float(value_str)
            return default if math.isnan(float_val) or math.isinf(float_val) else float_val
        except (ValueError, TypeError): return default

    async def get_ohlcv_data(self, symbol: str, period: str = "D", count: int = 100) -> List[OHLCVData]:
        """OHLCV Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        try:
            if not symbol or len(symbol) != 6 or not symbol.isdigit():
                raise KISDataValidationError(f"Invalid symbol format: {symbol}")
            
            self.logger.debug(f"üìà {symbol} OHLCV Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë...")
            
            # KIS API ÏùºÎ¥â Ï∞®Ìä∏ Ï°∞Ìöå
            result = await self._make_api_request(
                method="GET",
                endpoint="/uapi/domestic-stock/v1/quotations/inquire-daily-itemchartprice",
                params={
                    "FID_COND_MRKT_DIV_CODE": "J",
                    "FID_INPUT_ISCD": symbol,
                    "FID_INPUT_DATE_1": "",  # ÏãúÏûëÏùº (Í≥µÎ∞±Ïãú ÏµúÍ∑º Îç∞Ïù¥ÌÑ∞)
                    "FID_INPUT_DATE_2": "",  # Ï¢ÖÎ£åÏùº (Í≥µÎ∞±Ïãú ÏµúÍ∑º Îç∞Ïù¥ÌÑ∞)  
                    "FID_PERIOD_DIV_CODE": period,  # D=ÏùºÎ¥â, W=Ï£ºÎ¥â, M=ÏõîÎ¥â
                    "FID_ORG_ADJ_PRC": "0"   # 0=ÏàòÏ†ïÏ£ºÍ∞Ä, 1=ÏõêÏ£ºÍ∞Ä
                },
                tr_id="FHKST03010100"
            )
            
            output = result.get('output2', [])
            if not output:
                self.logger.warning(f"‚ö†Ô∏è {symbol} OHLCV Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
                return []
            
            # ÏùëÎãµ Îç∞Ïù¥ÌÑ∞Î•º OHLCVData Í∞ùÏ≤¥Î°ú Î≥ÄÌôò
            ohlcv_data = []
            for item in output[:count]:  # ÏµúÎåÄ countÍ∞úÍπåÏßÄÎßå
                try:
                    date_str = item.get('stck_bsop_date', '')  # ÏòÅÏóÖÏùºÏûê
                    if not date_str or len(date_str) != 8:
                        continue
                    
                    # ÎÇ†Ïßú ÌååÏã± (YYYYMMDD ÌòïÏãù)
                    chart_date = datetime.strptime(date_str, '%Y%m%d')
                    
                    # Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÌååÏã± Î∞è Í≤ÄÏ¶ù
                    open_price = self._safe_int_parse(item.get('stck_oprc', '0'))
                    high_price = self._safe_int_parse(item.get('stck_hgpr', '0'))
                    low_price = self._safe_int_parse(item.get('stck_lwpr', '0'))
                    close_price = self._safe_int_parse(item.get('stck_clpr', '0'))
                    volume = self._safe_int_parse(item.get('acml_vol', '0'))
                    trade_amount = self._safe_int_parse(item.get('acml_tr_pbmn', '0'))
                    
                    # Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù
                    if all(p > 0 for p in [open_price, high_price, low_price, close_price]):
                        ohlcv_item = OHLCVData(
                            symbol=symbol,
                            datetime=chart_date,
                            timeframe=period.lower(),
                            open_price=open_price,
                            high_price=high_price,
                            low_price=low_price,
                            close_price=close_price,
                            volume=volume,
                            trade_amount=trade_amount
                        )
                        ohlcv_data.append(ohlcv_item)
                        
                except Exception as item_error:
                    self.logger.debug(f"OHLCV ÏïÑÏù¥ÌÖú ÌååÏã± Ïã§Ìå® {symbol}: {item_error}")
                    continue
            
            # ÎÇ†ÏßúÏàú Ï†ïÎ†¨ (ÏµúÏã†Ïàú)
            ohlcv_data.sort(key=lambda x: x.datetime, reverse=True)
            
            self.logger.debug(f"‚úÖ {symbol} OHLCV {len(ohlcv_data)}Í∞ú Ï°∞Ìöå ÏÑ±Í≥µ")
            return ohlcv_data
            
        except KISAPIError:
            raise
        except Exception as e:
            self.logger.error(f"‚ùå {symbol} OHLCV Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®: {e}")
            raise KISAPIError(f"Failed to fetch OHLCV data: {e}")

    async def load_hts_conditions(self) -> bool:
        """HTS Ï°∞Í±¥Ïãù Î°úÎìú"""
        try:
            if not self.pykis_api:
                self.logger.warning("PyKis not available for HTS conditions")
                return False
                
            # PyKis 2.x Î≤ÑÏ†ÑÏóêÏÑúÎäî ÏûêÎèôÏúºÎ°ú Ï°∞Í±¥ÏãùÏù¥ Î°úÎìúÎê®
            self.logger.info("‚úÖ HTS Ï°∞Í±¥Ïãù Î°úÎìú ÏôÑÎ£å (PyKis 2.x auto-load)")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå HTS Ï°∞Í±¥Ïãù Î°úÎìú Ïã§Ìå®: {e}")
            return False

    async def get_hts_condition_list(self) -> List[Dict[str, str]]:
        """HTSÏóê Ï†ÄÏû•Îêú Ï°∞Í±¥Ïãù Î™©Î°ùÏùÑ APIÎ•º ÌÜµÌï¥ ÏßÅÏ†ë Ï°∞Ìöå (Í≥µÏãù API Ïä§Ìéô Ï§ÄÏàò)"""
        try:
            self.logger.info("üì° KIS APIÎ•º ÌÜµÌï¥ HTS Ï°∞Í±¥Ïãù Î™©Î°ù Ï°∞Ìöå Ï§ë...")
            
            # Í≥µÏãù API Ïä§ÌéôÏóê Îî∞Î•∏ ÏöîÏ≤≠
            result = await self._make_api_request(
                method="GET",
                endpoint="/uapi/domestic-stock/v1/quotations/psearch-title",
                params={"user_id": self.config.kis_account.KIS_USER_ID},
                tr_id="HHKST03900300",
                custtype="P"  # Í∞úÏù∏ Í≥†Í∞ù ÌÉÄÏûÖ
            )

            # Í≥µÏãù Ïä§Ìéô: output2 ÌïÑÎìúÏóê Í≤∞Í≥º Ìè¨Ìï®
            output2 = result.get('output2', [])
            if not output2:
                self.logger.warning("‚ö†Ô∏è HTSÏóê Ï†ÄÏû•Îêú Ï°∞Í±¥ÏãùÏù¥ ÏóÜÍ±∞ÎÇò API Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.")
                self.logger.debug(f"API ÏùëÎãµ: {result}")
                return []

            # Í≥µÏãù Ïä§ÌéôÏóê Îî∞Î•∏ ÌòïÏãù Î≥ÄÌôò: {'id': 'seq', 'name': 'condition_nm'}
            condition_list = []
            for item in output2:
                if 'seq' in item and 'condition_nm' in item:
                    condition_list.append({
                        "id": item['seq'],
                        "name": item['condition_nm'],
                        "grp_nm": item.get('grp_nm', ''),
                        "user_id": item.get('user_id', '')
                    })
            
            self.logger.info(f"‚úÖ APIÎ•º ÌÜµÌï¥ {len(condition_list)}Í∞úÏùò HTS Ï°∞Í±¥Ïãù Î™©Î°ù Ï°∞Ìöå ÏÑ±Í≥µ")
            for condition in condition_list:
                self.logger.debug(f"  - [{condition['id']}] {condition['name']}")
            
            return condition_list

        except Exception as e:
            self.logger.error(f"‚ùå HTS Ï°∞Í±¥Ïãù Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []

    async def get_stocks_by_condition(self, condition_id: str, condition_name: str = "") -> List[Dict]:
        """HTS Ï°∞Í±¥ÏãùÏúºÎ°ú Ï¢ÖÎ™© Í≤ÄÏÉâ - KIS API ÏßÅÏ†ë Ìò∏Ï∂ú (Í≥µÏãù API Ïä§Ìéô Ï§ÄÏàò)"""
        try:
            self.logger.info(f"üìä HTS Ï°∞Í±¥Ïãù {condition_id} ({condition_name}) Ï¢ÖÎ™© Í≤ÄÏÉâ Ï§ë...")

            # Í≥µÏãù API Ïä§ÌéôÏóê Îî∞Î•∏ Ï¢ÖÎ™© Ï°∞Ìöå
            result = await self._make_api_request(
                method="GET",
                endpoint="/uapi/domestic-stock/v1/quotations/psearch-result",
                params={
                    "user_id": self.config.kis_account.KIS_USER_ID,
                    "seq": str(condition_id)  # seqÎäî Î¨∏ÏûêÏó¥Î°ú Ï†ÑÎã¨
                },
                tr_id="HHKST03900400",
                custtype="P"  # Í∞úÏù∏ Í≥†Í∞ù ÌÉÄÏûÖ
            )

            # Í≥µÏãù Ïä§Ìéô: output2 ÌïÑÎìúÏóê Ï¢ÖÎ™© Ï†ïÎ≥¥ Ìè¨Ìï®
            output2 = result.get('output2', [])
            if not output2:
                self.logger.warning(f"‚ö†Ô∏è Ï°∞Í±¥Ïãù {condition_id} ({condition_name})Ïóê Ìï¥ÎãπÌïòÎäî Ï¢ÖÎ™© ÏóÜÏùå")
                # MCA05918 ÏóêÎü¨Îäî Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä 0Í∞úÏù∏ Í≤ΩÏö∞
                if result.get('msg_cd') == 'MCA05918':
                    self.logger.debug(f"Í≤ÄÏÉâ Í≤∞Í≥º 0Í∞ú: {result.get('msg1')}")
                return []

            # Í≥µÏãù Ïä§ÌéôÏóê Îî∞Î•∏ Ï¢ÖÎ™© Ï†ïÎ≥¥ Î≥ÄÌôò
            stocks_data = []
            for item in output2:
                if 'code' in item and 'name' in item:
                    stock_info = {
                        'code': item['code'],
                        'name': item['name'],
                        'price': float(item.get('price', '0').replace(',', '')),
                        'change': float(item.get('change', '0').replace(',', '')),
                        'chgrate': float(item.get('chgrate', '0').replace(',', '')),
                        'volume': int(float(item.get('acml_vol', '0').replace(',', ''))),
                        'market_cap': float(item.get('stotprice', '0').replace(',', ''))
                    }
                    stocks_data.append(stock_info)
            
            self.logger.info(f"‚úÖ Ï°∞Í±¥Ïãù {condition_id} ({condition_name})Î°ú {len(stocks_data)}Í∞ú Ï¢ÖÎ™© Î∞úÍ≤¨")
            
            # ÏÉÅÏúÑ Ï¢ÖÎ™©Îì§ Î°úÍ∑∏ Ï∂úÎ†•
            for i, stock in enumerate(stocks_data[:5]):
                self.logger.debug(f"  {i+1}. {stock['code']} {stock['name']} - {stock['price']:,.0f}Ïõê ({stock['chgrate']:+.2f}%)")
            
            return stocks_data

        except Exception as e:
            self.logger.error(f"‚ùå Ï°∞Í±¥Ïãù {condition_id} ({condition_name}) Í≤ÄÏÉâ Ïã§Ìå®: {e}")
            return []

    async def get_news_data(self, symbol: str, name: str, days: int = 7) -> List[Dict]:
        """Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë - KIS API Ïã§Ï†ú Ìò∏Ï∂ú ÏãúÎèÑ"""
        try:
            self.logger.info(f"üì∞ {symbol}({name}) Ïã§Ï†ú Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏãúÏûë...")
            
            # Ïã§Ï†ú KIS API Îâ¥Ïä§ Ìò∏Ï∂ú ÏãúÎèÑ
            real_news = []
            if self.pykis_api:
                try:
                    # PyKis APIÎ°ú Ïã§Ï†ú Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå ÏãúÎèÑ
                    # Ïã§Ï†ú Íµ¨ÌòÑ: Ï¢ÖÎ™© Í¥ÄÎ†® Îâ¥Ïä§ API Ìò∏Ï∂ú
                    import asyncio
                    news_result = await asyncio.to_thread(
                        self._get_stock_news_from_kis, symbol, name, days
                    )
                    if news_result and len(news_result) > 0:
                        real_news = news_result
                        self.logger.info(f"‚úÖ {symbol} Ïã§Ï†ú KIS Îâ¥Ïä§ {len(real_news)}Í±¥ ÏàòÏßë ÏôÑÎ£å")
                    else:
                        self.logger.debug(f"üì∞ {symbol} KIS APIÏóêÏÑú Îâ¥Ïä§ ÏóÜÏùå")
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è {symbol} KIS API Îâ¥Ïä§ Ï°∞Ìöå Ïã§Ìå®: {e}")
            
            # KIS API Ïã§Ìå® Ïãú Ïã§Ï†ú Ïõπ Îâ¥Ïä§ ÌÅ¨Î°§ÎßÅ ÏãúÎèÑ (Í∞ÑÎã®Ìïú Íµ¨ÌòÑ)
            if not real_news:
                try:
                    web_news = await self._crawl_web_news(symbol, name, days)
                    if web_news and len(web_news) > 0:
                        real_news = web_news
                        self.logger.info(f"‚úÖ {symbol} Ïõπ Îâ¥Ïä§ {len(real_news)}Í±¥ ÏàòÏßë ÏôÑÎ£å")
                    else:
                        self.logger.debug(f"üì∞ {symbol} ÏõπÏóêÏÑú Îâ¥Ïä§ ÏóÜÏùå")
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è {symbol} Ïõπ Îâ¥Ïä§ ÌÅ¨Î°§ÎßÅ Ïã§Ìå®: {e}")
            
            # Ïã§Ï†ú Îâ¥Ïä§Í∞Ä ÏûàÏúºÎ©¥ Î∞òÌôò
            if real_news and len(real_news) > 0:
                return real_news[:10]  # ÏµúÍ∑º 10Í∞úÎßå Î∞òÌôò
            
            # Ïã§Ï†ú Îâ¥Ïä§Í∞Ä ÏóÜÏúºÎ©¥ Îπà Î¶¨Ïä§Ìä∏ Î∞òÌôò (Í∏∞Î≥∏Í∞í Ï≤òÎ¶¨Îäî sentiment_analyzerÏóêÏÑú)
            self.logger.debug(f"üì∞ {symbol} Ïã§Ï†ú Îâ¥Ïä§ ÏóÜÏùå - Îπà Îç∞Ïù¥ÌÑ∞ Î∞òÌôò")
            return []
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è {symbol} Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®: {e}")
            return []

    async def get_filtered_stocks(self, limit: int = 20) -> List[Tuple[str, str]]:
        """
        ÌïÑÌÑ∞ÎßÅÎêú Ï¢ÖÎ™© Î¶¨Ïä§Ìä∏ Î∞òÌôò (Îã§Ï§ë ÏÜåÏä§ ÌôúÏö©)
        1. KIS HTS Ï°∞Í±¥Í≤ÄÏÉâ (ÏÇ¨Ïö©Ïûê ID ÏÑ§Ï†ï Ïãú)
        2. KIS API ÏãúÍ∞ÄÏ¥ùÏï° ÏÉÅÏúÑ Ï¢ÖÎ™© (Fallback)
        3. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï∫êÏãú (ÏµúÌõÑÏùò Fallback)
        """
        self.logger.info(f"üìä {limit}Í∞ú ÌïÑÌÑ∞ÎßÅ Ï¢ÖÎ™© Ï°∞Ìöå ÏãúÏûë (Îã§Ï§ë ÏÜåÏä§ ÌôúÏö©)...")
        stock_list = []
        
        # 1. KIS HTS Ï°∞Í±¥Í≤ÄÏÉâ (ÏÇ¨Ïö©Ïûê IDÍ∞Ä ÏÑ§Ï†ïÎêú Í≤ΩÏö∞ÏóêÎßå ÏãúÎèÑ)
        if hasattr(self.config, 'kis_account') and self.config.kis_account.KIS_USER_ID:
            try:
                self.logger.info("1Ô∏è‚É£ HTS Ï°∞Í±¥Í≤ÄÏÉâ ÏãúÎèÑ...")
                # 'momentum' Ï°∞Í±¥Ïãù IDÎ•º ÎèôÏ†ÅÏúºÎ°ú Ï∞æÍ±∞ÎÇò, ÏÑ§Ï†ï ÌååÏùºÏóêÏÑú Í∞ÄÏ†∏Ïò§ÎèÑÎ°ù Í∞úÏÑ† Í∞ÄÎä•
                # Ïó¨Í∏∞ÏÑúÎäî 'momentum' Ïù¥ÎùºÎäî Ïù¥Î¶ÑÏùò Ï°∞Í±¥ÏãùÏù¥ ÏûàÎã§Í≥† Í∞ÄÏ†ï
                conditions = await self.get_hts_condition_list()
                momentum_condition = next((c for c in conditions if 'momentum' in c.get('name', '').lower()), None)

                if momentum_condition:
                    self.logger.info(f"'momentum' Ï°∞Í±¥Ïãù Î∞úÍ≤¨ (ID: {momentum_condition['id']})")
                    momentum_stocks = await self.get_stocks_by_condition(momentum_condition['id'], momentum_condition['name'])
                    
                    for stock_data in momentum_stocks:
                        symbol = stock_data.get('code')
                        name = stock_data.get('name')
                        if symbol and name:
                            stock_list.append((symbol, name))
                            if len(stock_list) >= limit:
                                break
                    
                    self.logger.info(f"‚úÖ HTS Ï°∞Í±¥Í≤ÄÏÉâÏúºÎ°ú {len(stock_list)}Í∞ú Ï¢ÖÎ™© Ï°∞Ìöå ÏÑ±Í≥µ")

                else:
                    self.logger.warning("‚ö†Ô∏è HTSÏóêÏÑú 'momentum' Ï°∞Í±¥ÏãùÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")

            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è HTS Ï°∞Í±¥Í≤ÄÏÉâ Ïã§Ìå®: {e}")
        else:
            self.logger.info("‚ÑπÔ∏è KIS_USER_IDÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïÑ HTS Ï°∞Í±¥Í≤ÄÏÉâÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§.")

        # 2. HTS Ï°∞Í±¥Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä Ï∂©Î∂ÑÌïòÏßÄ ÏïäÏúºÎ©¥, KIS APIÎ°ú ÏãúÏ¥ù ÏÉÅÏúÑ Ï¢ÖÎ™© Ï°∞Ìöå
        if len(stock_list) < limit:
            try:
                self.logger.info("2Ô∏è‚É£ KIS API ÏãúÍ∞ÄÏ¥ùÏï° ÏÉÅÏúÑ Ï¢ÖÎ™© Ï°∞Ìöå ÏãúÎèÑ...")
                top_stocks = await self._get_top_stocks_from_kis_api(limit=limit * 2) # Ïó¨Ïú†ÏûàÍ≤å Ï°∞Ìöå
                
                # HTS Í≤∞Í≥ºÏôÄ Ï§ëÎ≥µÎêòÏßÄ ÏïäÍ≤å Ï∂îÍ∞Ä
                existing_symbols = {s[0] for s in stock_list}
                for symbol, name in top_stocks:
                    if symbol not in existing_symbols:
                        stock_list.append((symbol, name))
                    if len(stock_list) >= limit:
                        break
                
                self.logger.info(f"‚úÖ KIS API ÏãúÏ¥ù ÏÉÅÏúÑ Ï¢ÖÎ™© Ï∂îÍ∞Ä ÌõÑ Ï¥ù {len(stock_list)}Í∞ú Ï¢ÖÎ™© ÌôïÎ≥¥")

            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è KIS API ÏãúÏ¥ù ÏÉÅÏúÑ Ï¢ÖÎ™© Ï°∞Ìöå Ïã§Ìå®: {e}")

        # 3. Í∑∏ÎûòÎèÑ Ï¢ÖÎ™©Ïù¥ ÏóÜÏúºÎ©¥, ÏµúÌõÑÏùò ÏàòÎã®ÏúºÎ°ú DB Ï∫êÏãú ÏÇ¨Ïö© (Ïù¥ Í∏∞Îä•ÏùÄ Ïô∏Î∂ÄÏóêÏÑú Ìò∏Ï∂ú)
        if not stock_list:
            self.logger.warning("‚ö†Ô∏è Î™®Îì† Ï¢ÖÎ™© ÏÜåÏä§ÏóêÏÑú Ï¢ÖÎ™©ÏùÑ Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§. DB Ï∫êÏãúÎ•º ÌôïÏù∏Ìï¥Ïïº Ìï† Ïàò ÏûàÏäµÎãàÎã§.")
            # DB Ï∫êÏãú Ï°∞Ìöå Î°úÏßÅÏùÄ Ïó¨Í∏∞Ïóê ÏßÅÏ†ë Íµ¨ÌòÑÌïòÍ∏∞Î≥¥Îã§, Ïù¥ Î©îÏÑúÎìúÎ•º Ìò∏Ï∂úÌïòÎäî Ï™ΩÏóêÏÑú Ï≤òÎ¶¨ÌïòÎäî Í≤ÉÏù¥ Ï¢ãÏùå
            # Ïòà: trading_system.pyÏóêÏÑú Ïù¥ Î©îÏÑúÎìú Í≤∞Í≥ºÍ∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ DBÏóêÏÑú Î°úÎìú

        return stock_list[:limit]

    def _get_stock_news_from_kis(self, symbol: str, name: str, days: int = 7) -> List[Dict]:
        """KIS APIÎ°ú Ï¢ÖÎ™© Îâ¥Ïä§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (ÎèôÍ∏∞ Î©îÏÑúÎìú)"""
        try:
            # ÌòÑÏû¨ KIS APIÏóê Îâ¥Ïä§ Ï°∞Ìöå Í∏∞Îä•Ïù¥ ÏóÜÏúºÎØÄÎ°ú Îπà Î¶¨Ïä§Ìä∏ Î∞òÌôò
            # Ïã§Ï†ú ÏÑúÎπÑÏä§ÏóêÏÑúÎäî KIS APIÏùò Îâ¥Ïä§ Í¥ÄÎ†® ÏóîÎìúÌè¨Ïù∏Ìä∏Î•º Íµ¨ÌòÑ
            self.logger.debug(f"üì∞ {symbol} KIS API Îâ¥Ïä§ Ï°∞Ìöå (ÌòÑÏû¨ ÎØ∏ÏßÄÏõê)")
            return []
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è KIS API Îâ¥Ïä§ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []
    
    async def _crawl_web_news(self, symbol: str, name: str, days: int = 7) -> List[Dict]:
        """ÏõπÏóêÏÑú Ïã§Ï†ú Îâ¥Ïä§ ÌÅ¨Î°§ÎßÅ"""
        try:
            import aiohttp
            from datetime import datetime, timedelta
            
            news_list = []
            
            # ÎÑ§Ïù¥Î≤Ñ Í∏àÏúµ Îâ¥Ïä§ ÌÅ¨Î°§ÎßÅ ÏãúÎèÑ
            try:
                search_url = f"https://finance.naver.com/item/news_news.naver?code={symbol}"
                
                if self.session:
                    async with self.session.get(search_url, timeout=10) as response:
                        if response.status == 200:
                            html_content = await response.text()
                            
                            # Í∞ÑÎã®Ìïú HTML ÌååÏã± (Beautiful Soup ÏóÜÏù¥)
                            import re
                            
                            # Ï†úÎ™©Í≥º ÎÇ¥Ïö© Ìå®ÌÑ¥ Îß§Ïπ≠
                            title_pattern = r'<dd class="title"><a[^>]*>([^<]+)</a>'
                            date_pattern = r'<dd class="date">([^<]+)</dd>'
                            
                            titles = re.findall(title_pattern, html_content)
                            dates = re.findall(date_pattern, html_content)
                            
                            # ÏµúÎåÄ 5Í∞ú Îâ¥Ïä§ Ï≤òÎ¶¨
                            for i, (title, date_str) in enumerate(zip(titles[:5], dates[:5])):
                                if title and date_str:
                                    news_item = {
                                        'title': title.strip(),
                                        'description': f"{name} Í¥ÄÎ†® Îâ¥Ïä§",
                                        'content': f"{name}Ïóê ÎåÄÌïú Îâ¥Ïä§ ÎÇ¥Ïö©ÏûÖÎãàÎã§.",
                                        'published_date': date_str.strip(),
                                        'source': "ÎÑ§Ïù¥Î≤Ñ Í∏àÏúµ",
                                        'url': search_url
                                    }
                                    news_list.append(news_item)
                            
                            if news_list:
                                self.logger.info(f"‚úÖ {symbol} ÎÑ§Ïù¥Î≤Ñ Í∏àÏúµÏóêÏÑú {len(news_list)}Í±¥ Îâ¥Ïä§ ÏàòÏßë")
                                return news_list
                            
            except Exception as e:
                self.logger.debug(f"üì∞ {symbol} ÎÑ§Ïù¥Î≤Ñ Í∏àÏúµ ÌÅ¨Î°§ÎßÅ Ïã§Ìå®: {e}")
            
            # Îã§Ïùå Ïπ¥Ïπ¥Ïò§ Í∏àÏúµ Îâ¥Ïä§ ÌÅ¨Î°§ÎßÅ ÏãúÎèÑ
            try:
                daum_url = f"https://finance.daum.net/quotes/A{symbol}"
                
                if self.session:
                    async with self.session.get(daum_url, timeout=10) as response:
                        if response.status == 200:
                            html_content = await response.text()
                            
                            # Í∞ÑÎã®Ìïú Îâ¥Ïä§ Ï†úÎ™© Ï∂îÏ∂ú
                            import re
                            news_pattern = r'<a[^>]*class="[^"]*link_news[^"]*"[^>]*>([^<]+)</a>'
                            news_titles = re.findall(news_pattern, html_content)
                            
                            # ÏµúÎåÄ 3Í∞ú Îâ¥Ïä§ Ï≤òÎ¶¨
                            for i, title in enumerate(news_titles[:3]):
                                if title.strip():
                                    news_item = {
                                        'title': title.strip(),
                                        'description': f"{name} Í¥ÄÎ†® Îâ¥Ïä§",
                                        'content': f"{name}Ïóê ÎåÄÌïú Îâ¥Ïä§ ÎÇ¥Ïö©ÏûÖÎãàÎã§.",
                                        'published_date': datetime.now().isoformat(),
                                        'source': "Îã§Ïùå Í∏àÏúµ",
                                        'url': daum_url
                                    }
                                    news_list.append(news_item)
                            
                            if news_list:
                                self.logger.info(f"‚úÖ {symbol} Îã§Ïùå Í∏àÏúµÏóêÏÑú {len(news_list)}Í±¥ Îâ¥Ïä§ ÏàòÏßë")
                                return news_list
                                
            except Exception as e:
                self.logger.debug(f"üì∞ {symbol} Îã§Ïùå Í∏àÏúµ ÌÅ¨Î°§ÎßÅ Ïã§Ìå®: {e}")
            
            # Î™®Îì† ÌÅ¨Î°§ÎßÅ Ïã§Ìå® Ïãú Îπà Î¶¨Ïä§Ìä∏ Î∞òÌôò
            self.logger.debug(f"üì∞ {symbol} Ïã§Ï†ú Ïõπ Îâ¥Ïä§ ÌÅ¨Î°§ÎßÅ Í≤∞Í≥º ÏóÜÏùå")
            return []
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è {symbol} Ïõπ Îâ¥Ïä§ ÌÅ¨Î°§ÎßÅ Ïã§Ìå®: {e}")
            return []

    async def _get_top_stocks_from_kis_api(self, limit: int = 20) -> List[Tuple[str, str]]:
        """KIS API ÏßÅÏ†ë Ìò∏Ï∂úÎ°ú KOSPI 200 Íµ¨ÏÑ± Ï¢ÖÎ™© Ï°∞Ìöå"""
        try:
            self.logger.info(f"üìä KIS APIÎ°ú KOSPI 200 Íµ¨ÏÑ± Ï¢ÖÎ™© {limit}Í∞ú Ï°∞Ìöå Ï§ë...")
            
            # KOSPI 200 ÏßÄÏàò (ÏóÖÏ¢ÖÏΩîÎìú: 001)
            result = await self._make_api_request(
                method="GET",
                endpoint="/uapi/domestic-stock/v1/quotations/inquire-index-constituent-stocks",
                params={
                    "FID_COND_MRKT_DIV_CODE": "U",
                    "FID_INPUT_ISCD": "001",  # KOSPI 200
                },
                tr_id="FHPUP03100000"
            )
            
            output = result.get('output', [])
            if not output:
                self.logger.warning("‚ö†Ô∏è KIS API KOSPI 200 Ï°∞Ìöå Í≤∞Í≥º ÏóÜÏùå")
                return []
            
            stock_list = []
            for item in output[:limit]:
                symbol = item.get('stck_shrn_iscd', '').zfill(6)
                name = self._clean_stock_name(item.get('hts_kor_isnm', ''))
                if symbol and name:
                    stock_list.append((symbol, name))
            
            if stock_list:
                self.logger.info(f"‚úÖ KIS APIÎ°ú KOSPI 200 {len(stock_list)}Í∞ú Ï¢ÖÎ™© Ï°∞Ìöå ÏôÑÎ£å")
                return stock_list
            else:
                self.logger.warning("‚ö†Ô∏è KIS API Ï°∞Ìöå ÏÑ±Í≥µÌñàÏúºÎÇò Ïú†Ìö®Ìïú KOSPI 200 Ï¢ÖÎ™© ÏóÜÏùå")
                return []
                
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è KIS API KOSPI 200 ÏßÅÏ†ë Ìò∏Ï∂ú Ïã§Ìå®: {e}")
            return []

    async def get_investor_trading_data(self, symbol: str) -> Optional[Dict[str, Any]]:
        """ÌäπÏ†ï Ï¢ÖÎ™©Ïùò Ìà¨ÏûêÏûêÎ≥Ñ Îß§Îß§ ÎèôÌñ• Ï°∞Ìöå"""
        try:
            if not symbol or len(symbol) != 6 or not symbol.isdigit():
                raise KISDataValidationError(f"Invalid symbol format: {symbol}")
            
            self.logger.debug(f"üìä {symbol} Ìà¨ÏûêÏûêÎ≥Ñ Îß§Îß§ ÎèôÌñ• Ï°∞Ìöå Ï§ë...")
            
            today = datetime.now().strftime('%Y%m%d')
            
            result = await self._make_api_request(
                method="GET",
                endpoint="/uapi/domestic-stock/v1/quotations/inquire-investor-trend",
                params={
                    "FID_COND_MRKT_DIV_CODE": "J",
                    "FID_INPUT_ISCD": symbol,
                    "FID_INPUT_DATE_1": today,
                    "FID_INPUT_DATE_2": today,
                    "FID_PERIOD_DIV_CODE": "D", # ÏùºÎ≥Ñ
                    "FID_ORG_ADJ_PRC": "0"
                },
                tr_id="FHKST01010400"
            )
            
            output = result.get('output1', [])
            if not output:
                self.logger.warning(f"‚ö†Ô∏è {symbol} Ìà¨ÏûêÏûêÎ≥Ñ Îß§Îß§ ÎèôÌñ• Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
                return None

            # ÏµúÏã† Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            latest_data = output[0]

            investor_data = {
                'foreign': {
                    'net_buying': self._safe_int_parse(latest_data.get('frgn_ntby_qty', '0')),
                    'buy_volume': self._safe_int_parse(latest_data.get('frgn_shnu_vol', '0')),
                    'sell_volume': self._safe_int_parse(latest_data.get('frgn_seln_vol', '0')),
                },
                'institution': {
                    'net_buying': self._safe_int_parse(latest_data.get('orgn_ntby_qty', '0')),
                    'buy_volume': self._safe_int_parse(latest_data.get('orgn_shnu_vol', '0')),
                    'sell_volume': self._safe_int_parse(latest_data.get('orgn_seln_vol', '0')),
                },
                'individual': {
                    'net_buying': self._safe_int_parse(latest_data.get('prsn_ntby_qty', '0')),
                    'buy_volume': self._safe_int_parse(latest_data.get('prsn_shnu_vol', '0')),
                    'sell_volume': self._safe_int_parse(latest_data.get('prsn_seln_vol', '0')),
                }
            }
            self.logger.debug(f"‚úÖ {symbol} Ìà¨ÏûêÏûêÎ≥Ñ Îß§Îß§ ÎèôÌñ• Ï°∞Ìöå ÏÑ±Í≥µ")
            return investor_data

        except KISAPIError as e:
            self.logger.error(f"‚ùå {symbol} Ìà¨ÏûêÏûêÎ≥Ñ Îß§Îß§ ÎèôÌñ• Ï°∞Ìöå Ïã§Ìå®: {e}")
            return None
        except Exception as e:
            self.logger.error(f"‚ùå {symbol} Ìà¨ÏûêÏûêÎ≥Ñ Îß§Îß§ ÎèôÌñ• Ï°∞Ìöå Ï§ë ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•ò: {e}")
            return None

    async def cleanup(self):
        """Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨"""
        await self.close()